#!/usr/bin/env bash
set -euo pipefail

# Text helper colors
txtred='\e[0;31m' # Red
txtgrn='\e[0;32m' # Green
clroff='\e[0m'    # Color reset

grn_echo() { echo -e "${txtgrn}$@${clroff}" ;}
red_echo() { echo -e "${txtred}$@${clroff}" ;}

#
## Utility functions
#
ensure() {
    errors=""
    verify=$1 && shift
    for verifiable in "$@"; do
        $verify $verifiable >/dev/null \
            || errors+="${txtred}Mimipass requires \`$verify $verifiable\` to return true.\n${clroff}"
    done

    [ -z "$errors" ] || err "${errors%\\n}"
}

err()   { red_echo "$@" >&2 && return 1 ;}
say()   { grn_echo "$@" >&2 ;}

# higher order functions in shell! ;p
ensure-env() { ensure "test -v" "$@" ;}
ensure-commands() { ensure "command -v" "$@" ;}

# Verify environment
ensure-commands gpg openssl gpg-agent tr xargs awk
ensure-env MIMIPASS_HOME MIMIPASS_RECIPIENT

#
## Password recovery
#
mimipass-list() {
    (ls $MIMIPASS_HOME/*.gpg >/dev/null 2>&1) \
        || err 'No passwords available'

    say 'Mimipass available passwords:'
    ls -1 $MIMIPASS_HOME/*.gpg \
        | xargs -I {} -n1 basename {} .gpg \
        | xargs -I{} -n1 echo "* {}"
}

mimipass-get() {
    passwd_name=$1
    passwd_file=$MIMIPASS_HOME/$passwd_name.gpg

    if [ -f $passwd_file ]; then
        gpg -q --no-tty --use-agent -r $MIMIPASS_RECIPIENT -d $passwd_file
    else
        err "Couldn't find [ ${passwd_name} ] in the passwd list"
    fi
}

mimipass-copy() {
    passwd_name=$1
    ensure-commands xclip

    mimipass-get $passwd_name | xclip -i -selection clipboard \
        && say "Password [ $passwd_name ] sent to clipboard :)"
}

#
## Password set and generation
#
mimipass-set() {
    passwd_name=$1
    passwd_file=$MIMIPASS_HOME/$passwd_name.gpg

    say "Type the text. Press C-d when done."
    gpg --yes -a -r $MIMIPASS_RECIPIENT -o $passwd_file -e

    say "Done!"
}

mimipass-new() {
    size=${1:-64}

    openssl rand -base64 300 \
        | tr -d '\n' \
        | cut -c -$size
}
mimipass-new64() { mimipass-new 300 | tr -dc 'a-zA-Z0-9' | cut -c -${1:-64} ;}
mimipass-new-set() {
    passwd_name=$1
    size=${2:-}

    mimipass-new $size | mimipass-set $passwd_name 2>/dev/null
    say "Done!"
}
mimipass-new-set-copy() {
    passwd_name=$1
    size=${2:-}

    mimipass-new-set $passwd_name $size 2>/dev/null
    mimipass copy $passwd_name 2>/dev/null
    say "Done!"
}

mimipass-delete() {
    mimipass-delete-rec() {
        [ $# = 0 ] && return 0

        passwd_name=$1
        passwd_file=$MIMIPASS_HOME/$passwd_name.gpg

        [ ! -e $passwd_file ] \
            && err "Can't find password ${passwd_name}"

        rm $passwd_file

        shift && mimipass-delete-rec $@
    }

    local confirmed=false
    if [[ $1 = '-y'  || $1 = '--yes' ]]; then
        confirmed=true
        REPLY=y
        shift
    fi

    $confirmed || read -rp "Are you sure [y/N]? "
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        mimipass-delete-rec $@
        say "Done!"
    fi
}

#
## Secret key import and exporting
#
mimipass-import() {
    gpg --import $MIMIPASS_HOME/publickey.txt
    gpg --import $MIMIPASS_HOME/privatekey.txt

    mimipass-set-trust

    say "Done!"
}

mimipass-export() {
    gpg --export            -a -o $MIMIPASS_HOME/publickey.txt $MIMIPASS_RECIPIENT
    gpg --export-secret-key -a -o $MIMIPASS_HOME/privatekey.txt $MIMIPASS_RECIPIENT

    say "Done!"
}

mimipass-set-trust() {
    # see http://marc.info/?l=gnupg-users&m=128040167115023&w=2
    gpg --fingerprint --with-colons --list-keys \
        | awk -F: -v keyname="$MIMIPASS_RECIPIENT" -v trustlevel="6" '
        $1=="pub" && $10 ~ keyname { fpr=1 }
        $1=="fpr" && fpr { fpr=$10; exit }
        END {
            cmd="gpg --export-ownertrust"
            while (cmd | getline) if ($1!=fpr) print
            close(cmd)
            print fpr ":" trustlevel ":"
        }
    ' | gpg --import-ownertrust
}

# Invoke!
cmd=$1 && shift
mimipass-$cmd $@
